Commands
========

A Command is a parameterised, reusable action that (optionally) takes bound values from the request or elsewhere
and performs an action to give a result. These work best when constructed using the [Cake pattern](cake.md) and
combining several components together, so this documentation will exclusively use that method, based off
`ComposableCommand`.

Table of Contents
-----------------

- [Applying](#applying)
- [Binding data from the request](#binding-data-from-the-request)
- [Populating defaults in the request data](#populating-defaults-in-the-request-data)
- [Running code on bind (pre-validation)](#running-code-on-bind-pre-validation)
- [Validating data](#validating-data)
- [Audit logging (Describable)](#audit-logging-describable)
- [Read-only commands](#read-only-commands)
- [Notifications](#notifications)
  - [Sending notifications when a command runs](#sending-notifications-when-a-command-runs)
  - [Scheduling notifications for the future](#scheduling-notifications-for-the-future)
  - [Completing notifications](#completing-notifications)
- [Triggers](#triggers)
- [Benchmarking execution time](#benchmarking-execution-time)

Applying
--------

The main body of what a Command does is in its `apply()` method. With the cake pattern, the applying component
is implemented by a class that extends `CommandInternal[A]`, returning an `A` from an `applyInternal()` method.
Typically, you'll want this to perform some database operation so normally your `applyInternal` implementation
will wrap a body in `transactional() {}`, available with `import uk.ac.warwick.tabula.data.Transactions._`.

If your Command is a [read-only command](#read-only-commands) then use `transactional(readOnly = true) {}`.

The flow of `Command.apply()` is as follows:

1. If maintenance mode is enabled, check that the Command has the `ReadOnly` trait. Otherwise, halt execution and
   show an error message
2. Record a `before` [event](#audit-logging-describable) unless the Command is `Unaudited`
3. Run `applyInternal()` and get the result of the Command execution
4. Log any [benchmarking](#benchmarking-execution-time) for the Command execution
5. Push any [notifications generated by the command](#sending-notifications-when-a-command-runs)
6. [Schedule future notifications](#scheduling-notifications-for-the-future) generated by the command
7. Mark any [notifications that the command completes](#completing-notifications) as complete
8. Save any [triggers that the command generates](#triggers)
9. Record an `after` [event](#audit-logging-describable) unless the Command is `Unaudited`
10. Return the result to the caller (typically a Controller or another Command)

Binding data from the request
-----------------------------

Populating defaults in the request data
---------------------------------------

Running code on bind (pre-validation)
-------------------------------------

- Mixin `BindListener` on your command instead of calling `onBind` from a controller

Validating data
---------------

- Always add the `@Valid` annotation to the controller method argument.

- Use validation annotations on your commands for simple things if you want.

- For custom code, make the command extend `SelfValidating` and in the controller body do `validatesSelf[DeleteFeedbackCommand]`

Audit logging (Describable)
---------------------------

Read-only commands
------------------

Notifications
-------------

### Sending notifications when a command runs

### Scheduling notifications for the future

### Completing notifications

Triggers
--------

Benchmarking execution time
---------------------------
