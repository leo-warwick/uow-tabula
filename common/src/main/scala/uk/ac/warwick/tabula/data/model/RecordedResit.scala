package uk.ac.warwick.tabula.data.model

import javax.persistence.{Access, AccessType, Column, Entity}
import org.hibernate.annotations.{Proxy, Type}
import org.joda.time.DateTime
import uk.ac.warwick.tabula.JavaImports.JInteger
import uk.ac.warwick.tabula.commands.marks.ListAssessmentComponentsCommand.StudentMarkRecord
import uk.ac.warwick.tabula.services.healthchecks.WriteToSits
import uk.ac.warwick.tabula.{AcademicYear, SprCode, ToString}
import uk.ac.warwick.userlookup.User

/**
 * A Student Re-Assessment record generated by tabula awaiting upload to SITS
 */
@Entity
@Proxy
@Access(AccessType.FIELD)
class RecordedResit extends GeneratedId
  with HibernateVersioned
  with WriteToSits
  with ToString with Serializable {

  def this(mr: StudentMarkRecord, sprCode: String) = {
    this()
    val uag = mr.upstreamAssessmentGroupMember.upstreamAssessmentGroup
    val ac = uag.assessmentComponent
    this.sprCode = sprCode
    this.moduleCode = uag.moduleCode
    this.sequence = uag.sequence
    this.academicYear = uag.academicYear
    this.occurrence = uag.occurrence
    this.marksCode = ac.map(_.marksCode).orNull
  }

  @Column(name = "spr_code", nullable = false)
  var sprCode: String = _

  def universityId: Option[String] = Option(sprCode).map(SprCode.getUniversityId)

  // Long-form module code with hyphen and CATS value
  @Column(name = "module_code", nullable = false)
  var moduleCode: String = _

  @Type(`type` = "uk.ac.warwick.tabula.data.model.AcademicYearUserType")
  @Column(name = "academic_year", nullable = false)
  var academicYear: AcademicYear = _

  @Column(nullable = false)
  var occurrence: String = _

  @Column(nullable = false)
  var sequence: String = _

  @Column(name = "resit_sequence")
  private var _resitSequence: String = _
  def resitSequence: Option[String] = Option(_resitSequence)
  def resitSequence_=(resitSequence: Option[String]): Unit = _resitSequence = resitSequence.orNull

  @Column(name = "current_resit_attempt", nullable = false)
  var currentResitAttempt: JInteger = _

  @Type(`type` = "uk.ac.warwick.tabula.data.model.AssessmentTypeUserType")
  @Column(name = "assessment_type", nullable = false)
  var assessmentType: AssessmentType = _

  @Column(name = "marks_code", nullable = false)
  var marksCode: String = _

  @Column(name = "weighting", nullable = false)
  var weighting: JInteger = _

  @Type(`type` = "uk.ac.warwick.tabula.data.model.SSOUserType")
  @Column(name = "updated_by", nullable = false)
  var updatedBy: User = _

  @Column(name = "updated_date", nullable = false)
  var updatedDate: DateTime = _

  @Column(name = "needs_writing_to_sits_since")
  private var _needsWritingToSitsSince: DateTime = _
  def needsWritingToSitsSince: Option[DateTime] = Option(_needsWritingToSitsSince)
  def needsWritingToSitsSince_=(needsWritingToSitsSince: Option[DateTime]): Unit = _needsWritingToSitsSince = needsWritingToSitsSince.orNull
  def needsWritingToSits: Boolean = needsWritingToSitsSince.nonEmpty

  // empty for a resit that's never been written
  @Column(name = "last_written_to_sits")
  private var _lastWrittenToSits: DateTime = _
  def lastWrittenToSits: Option[DateTime] = Option(_lastWrittenToSits)
  def lastWrittenToSits_=(lastWrittenToSits: Option[DateTime]): Unit = _lastWrittenToSits = lastWrittenToSits.orNull

  override def toStringProps: Seq[(String, Any)] = Seq(
    "sprCode" -> sprCode,
    "moduleCode" -> moduleCode,
    "academicYear" -> academicYear,
    "occurrence" -> occurrence,
    "sequence" -> sequence,
    "resitSequence" -> resitSequence,
    "currentResitAttempt" -> currentResitAttempt,
    "assessmentType" -> assessmentType,
    "marksCode" -> marksCode,
    "weighting" -> weighting,
    "needsWritingToSitsSince" -> needsWritingToSitsSince,
    "lastWrittenToSits" -> lastWrittenToSits
  )
}
